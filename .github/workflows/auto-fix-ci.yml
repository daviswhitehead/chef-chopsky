name: Auto Fix CI Failures (MVP)

on:
  workflow_run:
    workflows: [CI, Test Chef Chopsky Agent]
    types: [completed]

jobs:
  analyze-and-fix:
    if: >-
      ${{ github.event.workflow_run.conclusion == 'failure' && github.event.workflow_run.name != 'Auto Fix CI Failures (MVP)' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm run install:all
      
      - name: Configure Git
        run: |
          git config user.name "Cursor Agent"
          git config user.email "cursoragent@cursor.com"
      
      - name: Extract failure context
        id: context
        run: |
          echo "WORKFLOW_RUN_ID=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          echo "WORKFLOW_RUN_URL=${{ github.event.workflow_run.html_url }}" >> $GITHUB_OUTPUT
          echo "HEAD_BRANCH=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
          echo "HEAD_SHA=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
      
      - name: Get PR information
        id: pr-info
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get PR number from the head branch
          PR_NUMBER=$(gh pr list --head "${{ steps.context.outputs.HEAD_BRANCH }}" --json number --jq '.[0].number' || echo "")
          if [ -z "$PR_NUMBER" ]; then
            echo "No PR found for branch ${{ steps.context.outputs.HEAD_BRANCH }}"
            exit 1
          fi
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "Found PR #$PR_NUMBER"
      
      - name: Create fix branch
        id: fix-branch
        run: |
          PR_NUMBER="${{ steps.pr-info.outputs.PR_NUMBER }}"
          FIX_BRANCH="ci-fix-${PR_NUMBER}"
          
          # Check if fix branch already exists
          if git show-ref --verify --quiet refs/remotes/origin/$FIX_BRANCH; then
            echo "Fix branch $FIX_BRANCH already exists, updating..."
            git checkout $FIX_BRANCH
            git pull origin $FIX_BRANCH
          else
            echo "Creating new fix branch $FIX_BRANCH"
            git checkout -b $FIX_BRANCH
          fi
          
          echo "FIX_BRANCH=$FIX_BRANCH" >> $GITHUB_OUTPUT
      
      - name: Install Cursor CLI
        run: |
          curl -fsSL https://cursor.com/install | bash
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
      
      - name: Fix CI failure with Cursor CLI
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          MODEL: gpt-5
          GH_TOKEN: ${{ github.token }}
          BRANCH_PREFIX: ci-fix
          PAGER: cat
          GH_PAGER: cat
          GIT_PAGER: cat
        run: |
          timeout 10m cursor-agent -p "You are operating in a GitHub Actions runner.

          The GitHub CLI is available as \`gh\` and authenticated via \`GH_TOKEN\`. Git is available. You have write access to repository contents and can comment on pull requests, but you must not create or edit PRs directly. Always run `gh` commands with `--no-pager`.


          # Context:
          - Repo: ${{ github.repository }}
          - Owner: ${{ github.repository_owner }}
          - Workflow Run ID: ${{ github.event.workflow_run.id }}
          - Workflow Run URL: ${{ github.event.workflow_run.html_url }}
          - Fix Branch Prefix: ${{ env.BRANCH_PREFIX }}

          # Goal:
          - Implement a two-step CI fix flow: First analyze the failure thoroughly, then attempt targeted fixes.

          # Step 1: Analysis Phase
          1) Identify the PR associated with the failed workflow run and determine its base and head branches.
          2) Download and analyze the failed workflow logs to understand the root cause.
          3) Examine the failing tests, build errors, or other CI issues.
          4) Create a comprehensive copy-paste ready prompt for interactive debugging that includes:
             - Complete error logs and stack traces
             - Relevant code files and their current state
             - Environment details (Node version, OS, dependencies)
             - Recent commits and changes that might have caused the issue
             - Specific test data and expected vs actual results
             - All context needed for someone to debug this in a separate Cursor session

          # Step 2: Fix Phase (only if analysis looks good)
          5) If the analysis reveals a clear, safe fix, implement it with minimal targeted edits.
          6) Maintain a persistent fix branch for this PR head using the Fix Branch Prefix from Context.
          7) Test the fix by running relevant commands (npm test, build, etc.).
          8) If fix is successful, commit and push to the fix branch.
          9) Post a PR comment explaining the fix with a quick-create PR link.

          # Output Requirements:
          - Print the complete copy-paste ready debugging prompt first (this is the primary deliverable)
          - If attempting a fix, clearly indicate when moving from analysis to fix phase
          - Include all necessary context in the debugging prompt (logs, code, environment, etc.)
          - Make the debugging prompt self-contained - someone should be able to copy it and debug immediately

          # Inputs and conventions:
          - Use \`gh api\`, \`gh run view\`, \`gh pr view\`, \`gh pr diff\`, \`gh pr list\`, \`gh run download\`, and git commands as needed.
          - Always run `gh` commands with `--no-pager` to avoid hanging.
          - If no clear fix is possible, focus on creating the best possible debugging prompt.

          When analysis is complete and debugging prompt is ready, print exactly DONE on a single line and exit immediately.
          " --force --model "$MODEL" --output-format=text
      
      
