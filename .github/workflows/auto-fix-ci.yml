name: Auto Fix CI Failures (MVP)

on:
  workflow_run:
    workflows: [CI, Test Chef Chopsky Agent]
    types: [completed]

jobs:
  analyze-and-fix:
    if: >-
      ${{ github.event.workflow_run.conclusion == 'failure' && github.event.workflow_run.name != 'Auto Fix CI Failures (MVP)' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm run install:all
      
      - name: Configure Git
        run: |
          git config user.name "Cursor Agent"
          git config user.email "cursoragent@cursor.com"
      
      - name: Extract failure context
        id: context
        run: |
          echo "WORKFLOW_RUN_ID=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          echo "WORKFLOW_RUN_URL=${{ github.event.workflow_run.html_url }}" >> $GITHUB_OUTPUT
          echo "HEAD_BRANCH=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
          echo "HEAD_SHA=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
      
      - name: Get PR information
        id: pr-info
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get PR number from the head branch
          PR_NUMBER=$(gh pr list --head "${{ steps.context.outputs.HEAD_BRANCH }}" --json number --jq '.[0].number' || echo "")
          if [ -z "$PR_NUMBER" ]; then
            echo "No PR found for branch ${{ steps.context.outputs.HEAD_BRANCH }}"
            exit 1
          fi
          echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "Found PR #$PR_NUMBER"
      
      - name: Create fix branch
        id: fix-branch
        run: |
          PR_NUMBER="${{ steps.pr-info.outputs.PR_NUMBER }}"
          FIX_BRANCH="ci-fix-${PR_NUMBER}"
          
          # Check if fix branch already exists
          if git show-ref --verify --quiet refs/remotes/origin/$FIX_BRANCH; then
            echo "Fix branch $FIX_BRANCH already exists, updating..."
            git checkout $FIX_BRANCH
            git pull origin $FIX_BRANCH
          else
            echo "Creating new fix branch $FIX_BRANCH"
            git checkout -b $FIX_BRANCH
          fi
          
          echo "FIX_BRANCH=$FIX_BRANCH" >> $GITHUB_OUTPUT
      
      - name: Install Cursor CLI
        run: |
          curl -fsSL https://cursor.com/install | bash
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
      
      - name: Fix CI failure with Cursor CLI
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          MODEL: gpt-5
          GH_TOKEN: ${{ github.token }}
          BRANCH_PREFIX: ci-fix
          PAGER: cat
          GH_PAGER: cat
          GIT_PAGER: cat
        run: |
          # Create a wrapper script to handle cursor-agent termination issues
          cat > cursor_wrapper.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Start cursor-agent in background
          cursor-agent -p "$1" --force --model "$2" --output-format=text > cursor_output.log 2>&1 &
          CURSOR_PID=$!
          
          # Function to cleanup
          cleanup() {
            echo "Cleaning up cursor-agent process..."
            kill $CURSOR_PID 2>/dev/null || true
            wait $CURSOR_PID 2>/dev/null || true
          }
          
          # Set trap for cleanup
          trap cleanup EXIT INT TERM
          
          # Monitor for completion signal
          while kill -0 $CURSOR_PID 2>/dev/null; do
            # Check if "DONE" appears in output
            if grep -q "^DONE$" cursor_output.log 2>/dev/null; then
              echo "✅ Detected completion signal, terminating cursor-agent..."
              cleanup
              break
            fi
            sleep 1
          done
          
          # Show the output
          cat cursor_output.log
          
          # Check if we completed successfully
          if grep -q "^DONE$" cursor_output.log; then
            echo "✅ Cursor-agent completed successfully"
            exit 0
          else
            echo "⚠️ Cursor-agent may not have completed properly"
            exit 1
          fi
          EOF
          
          chmod +x cursor_wrapper.sh
          
          # Run with timeout and explicit termination handling
          timeout 10m ./cursor_wrapper.sh "You are operating in a GitHub Actions runner.

          - Treat this as NON-INTERACTIVE. Never open editors or pagers.
          - Always run gh commands with: --no-pager --json ... --jq ...
          - Time budget: 5 minutes.
          - Edit budget: ≤2 files, ≤60 lines. No dependency changes.


          The GitHub CLI is available as \`gh\` and authenticated via \`GH_TOKEN\`. Git is available. You have write access to repository contents and can comment on pull requests, but you must not create or edit PRs directly.

          # Context:
          - Repo: ${{ github.repository }}
          - Owner: ${{ github.repository_owner }}
          - Workflow Run ID: ${{ github.event.workflow_run.id }}
          - Workflow Run URL: ${{ github.event.workflow_run.html_url }}
          - Fix Branch Prefix: ${{ env.BRANCH_PREFIX }}

          # Goal:
          - One-shot CI triage. First produce a self-contained debugging prompt; only then, if safe, make a minimal fix.


          # Step 1: Analysis Phase
          1) Identify the PR associated with the failed workflow run and determine its base and head branches.
          2) Download and analyze the failed workflow logs to understand the root cause.
          3) Examine the failing tests, build errors, or other CI issues.
          4) Create a copy-paste ready prompt for interactive debugging that includes:
             - Error log windows and stack traces (not full logs, just what's most relevant)
             - Relevant code files/snippets and their current state
             - Environment details (Node version, OS, dependencies)
             - Recent commits and changes that might have caused the issue
             - Specific test data and expected vs actual results
             - The most important context needed for someone to debug this in a separate Cursor session
          5) Produce a Repro Script (bash) that installs deps and runs the minimal failing test locally.


          # Step 2: Fix Phase (only if analysis looks good)
          5) If the analysis reveals a clear, safe fix, implement it with minimal targeted edits.
          6) Maintain a persistent fix branch for this PR head using the Fix Branch Prefix from Context.
          7) Test the fix by running relevant commands (npm test, build, etc.).
          8) If fix is successful, commit and push to the fix branch.
          9) Post a PR comment explaining the fix with a quick-create PR link.

          # Output Requirements:
          - Start with a concise “CI Fail Summary”.
          - Provide structured facts (repo/pr/branches/shas, runner, node, failing jobs).
          - Print the complete copy-paste ready debugging prompt (this is the primary deliverable).
          - Include all necessary context in the debugging prompt (logs, code, environment, etc.)
          - Make the debugging prompt self-contained - someone should be able to copy it and debug immediately.
          - If attempting a fix, clearly indicate when moving from analysis to fix phase
          - If a fix was applied: show changed files + minimal diffs, branch name, compare link, and the exact PR comment text.
          - Finally print a single-line JSON summary:
            RESULT_JSON: {"phase":"Analysis|Fix","pr":<n>,"head":"<ref>","base":"<ref>","fixBranch":"<ref>","commit":"<sha>","status":"success|skipped|failed","reason":"<short>"}


          # Inputs and conventions:
          - Use \`gh api\`, \`gh run view\`, \`gh pr view\`, \`gh pr diff\`, \`gh pr list\`, \`gh run download\`, and git commands as needed.
          - Always run \`gh\` commands with \`--no-pager\` to avoid hanging.
          - If no clear fix is possible, focus on creating the best possible debugging prompt.

          When analysis is complete and debugging prompt is ready, print exactly DONE on a single line and exit immediately." "$MODEL"