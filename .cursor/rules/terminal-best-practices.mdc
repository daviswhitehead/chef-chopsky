---
description: "Terminal best practices to prevent blocking processes, manage long-running commands safely, and avoid multi-command execution"
alwaysApply: true
---

# Terminal Best Practices

## üö® Critical: Never Block Terminal with Long-Running Processes

### ‚ùå NEVER DO THIS
- Run servers, watchers, or long-running processes in the foreground without a timeout
- Use commands that wait indefinitely (like `node server.js` without backgrounding)
- Block the terminal with interactive processes

### ‚úÖ ALWAYS DO THIS
- Use `&` to background long-running processes: `command &`
- Use `is_background: true` for tool calls that start servers
- Add timeouts or use `timeout` command when testing: `timeout 5s command || echo "Done"`
- Use `Ctrl+C` simulation or process management for cleanup
- Test endpoints with separate curl commands after backgrounding

### üîß Process Management Patterns

**Starting Servers:**
```bash
# ‚úÖ Good - background the process
npm run server &

# ‚úÖ Good - with timeout for testing
timeout 10s npm run server || echo "Server test completed"

# ‚úÖ Good - check if running
ps aux | grep "process-name" | grep -v grep
```

**Testing Endpoints:**
```bash
# ‚úÖ Good - test after backgrounding
command &
sleep 2
curl -s http://localhost:3000/health
```

**Cleanup:**
```bash
# ‚úÖ Good - kill background processes
kill %1 2>/dev/null || echo "Process already stopped"
pkill -f "process-name" 2>/dev/null || echo "No processes to kill"
```

### üéØ When to Use Each Approach

- **Background (`&`)**: When you need the process to keep running
- **Timeout**: When testing if something starts correctly
- **Foreground**: Only for quick, non-blocking commands
- **is_background: true**: For tool calls that start long-running processes

### üö® Red Flags
- Terminal hanging without response
- Commands that don't return to prompt
- Interactive processes without escape mechanism
- Long-running processes in foreground

### üí° Quick Recovery
If terminal gets blocked:
1. Use `Ctrl+C` to interrupt
2. Check for background processes: `ps aux | grep node`
3. Kill hanging processes: `pkill -f "process-name"`
4. Use `jobs` to see background jobs
5. Use `kill %1` to kill job 1, etc.

## üéØ Success Criteria
- Terminal always returns to prompt
- Long-running processes are properly managed
- Tests complete without hanging
- Cleanup happens automatically

---

## üö® CRITICAL: Single Command Per Line Only

### ‚ùå NEVER DO THIS
- Run multiple commands on the same line: `cd /path && npm install`
- Chain commands with `&&`, `||`, `;`, or `|` operators
- Use command substitution: `$(command)`
- Use backticks for command substitution: `command`
- Pipe commands: `command1 | command2`

### ‚úÖ ALWAYS DO THIS
- Run ONE command per terminal call
- Use separate tool calls for each command
- Change directory first, then run the command in a separate call
- Use absolute paths when possible to avoid directory changes

### Examples

**‚ùå WRONG - Multiple commands:**
```bash
cd /path/to/project && npm install
npm run build && npm test
cd frontend && npm start
```

**‚úÖ CORRECT - Single commands:**
```bash
# First call
cd /path/to/project

# Second call  
npm install

# Third call
npm run build

# Fourth call
npm test
```

### Implementation Guidelines

1. **Directory Changes**: Always use separate calls for `cd` and the actual command
2. **Sequential Operations**: Break down multi-step operations into individual commands
3. **Path Resolution**: Use absolute paths when possible to minimize directory changes
4. **Error Handling**: Each command should be self-contained with its own error handling

### Rationale

This rule prevents:
- Multi-allowlist states in Cursor
- Complex command chaining that's hard to debug
- Unclear error attribution when commands fail
- Terminal session management issues

### Enforcement

- Always review terminal commands before execution
- Break down any chained commands into individual steps
- Use separate tool calls for each command
- Prefer absolute paths over relative paths with directory changes