---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   **Environment Workflow and Testing Strategy:** Document the environment workflow, explaining the purpose of each environment (Development, Preview, Staging, and Production), the testing strategy for each, and the overall deployment workflow. Include environment-specific configurations and a cost-effective approach using free tiers.
*   **Staging Setup Guide:** Update the staging setup guide to reflect the separate Vercel project approach instead of using Vercel's built-in environment functionality. This includes architectural changes and step-by-step instructions for creating a separate staging project.
*   **Local Supabase via CLI:** Adopt Supabase CLI for local development database (Docker-based). Add `npm run supabase:start`/`supabase:stop` scripts and docs. Create `frontend/.env.local.example` pointing to local Supabase URL/anon key. Document migrations flow: `npx supabase db reset` for local; `db push` for staging/prod. Document environment mapping: Local (CLI) | Staging (hosted `chef-chopsky-staging`) | Production (hosted `chef-chopsky`). Note: the previous `chef-chopsky-local` hosted project has been repurposed as the staging project to stay within free tier limits. Document local Supabase setup and usage.
    *   **Environment Mapping:**
        *   **Local**: Supabase CLI (Docker) - `http://127.0.0.1:54321`
        *   **Staging**: Hosted Supabase project `chef-chopsky-staging`
        *   **Production**: Hosted Supabase project `chef-chopsky-production`

## TECH STACK

## CODING STANDARDS

## WORKFLOW & RELEASE RULES

*   **Vercel Environment Variables:** When setting environment variables in Vercel projects, the separate staging project approach uses the "production" environment type for the staging project. This is done to stay within free tier limits. This may impact the commands used to sync environment variables.
*   **Syncing Vercel Environment Variables:** The `sync-vercel-env.sh` script can be used to sync environment variables. The separate staging project uses the "production" environment type, so the command should be run with the `--environment production` flag.
    *   When syncing environment variables for the staging environment, first navigate to the frontend directory (`cd frontend`). Then, link the Vercel project (`vercel link --yes --project chef-chopsky-staging`). Finally, run the sync script from the parent directory (`cd ..; ./scripts/sync-vercel-env.sh --file frontend/.env.staging --environment production`).
*   **Feature Branch Staging Deployments**: The trigger for feature branch staging deployments uses the following logic:
    *   **Triggers**: The workflow is automatically triggered when code is pushed to any branch that starts with `feat/` or `feature/`.
    *   **URL Generation**: The deployment URL is created by taking the branch name (e.g., `feat/new-recipe-search`), replacing `/` with `-` (becomes `feat-new-recipe-search`), and creating the URL: `https://chef-chopsky-git-feat-new-recipe-search.vercel.app`.

## DEBUGGING

*   **Staging vs Production Supabase Credentials:** If staging writes are appearing in production, it's likely that the Vercel environment variables for both staging and production are linked to the same Supabase project. The `NEXT_PUBLIC_SUPABASE_URL` and keys should be different for each environment. To fix this:
    *   In Vercel, for the `chef-chopsky-staging` project, set `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY` to your STAGING project values and `SUPABASE_SECRET_KEY` to the STAGING service role key.
    *   In Vercel, for the `chef-chopsky` (production) project, ensure those three env vars are production values only. The production Supabase project is actually `chef-chopsky-production`, not `chef-chopsky`.
    *   Redeploy both projects after saving changes.

## AI CODING ASSISTANT RULES

### GENERAL BEHAVIOR
- You are an expert software engineer.
- Follow instructions precisely and completely.
- Ask clarifying questions before proceeding if instructions are ambiguous.
- Generate high-quality, well-documented code.
- Adhere to project standards and best practices.
- Focus on solving the user's problem efficiently and effectively.
- Use the tools available to you to gather information and complete tasks.
- Never expose secrets or API keys in the codebase or in any generated text.
- Use `docs/` to learn about architectural decisions, API usage, and data models.
- Use comments to explain complex code.
- Use descriptive variable names.
- Keep code DRY (Don't Repeat Yourself).
- Acknowledge all steps.

### TOOLS
- You have access to the following tools:
  - `codebase_search`: Search the codebase for relevant information.
  - `file_read`: Read the content of a file.
  - `file_write`: Write content to a file.
  - `file_delete`: Delete a file.
  - `mcp_cursor-playwright_browser_snapshot`: Take a screenshot of the browser.
  - `mcp_cursor-playwright_browser_console_messages`: Returns all console messages.
  - `mcp_cursor-playwright_browser_click`: Perform click on a web page
  - `mcp_cursor-playwright_browser_type`: Type text into editable element
  - `mcp_cursor-playwright_browser_wait_for`: Wait for text to appear or disappear or a specified time to pass
  - `mcp_Railway_get-logs`: Get the logs of a Railway service.
  - `mcp_Railway_list-variables`: List Railway environment variables.
  - `mcp_Railway_check-railway-status`: Check if Railway CLI is installed and user is logged in.
  - `mcp_Railway_set-variables`: Set environment variables for a Railway service.
  - `run_terminal_cmd`: Execute a terminal command.
  - `apply_patch`: Apply a patch to a file.
  - `web_search`: Web search for relevant information (e.g., library documentation, usage examples).
  - `list_dir`: List the files in a directory.
  - `glob_file_search`: Search for files matching a glob pattern.
  - `fetch_rules`: Fetch the active rules.
  - `mcp_vercel_list_teams`: List the user's teams.
  - `mcp_vercel_list_projects`: List all Vercel projects for a user.
  - `mcp_vercel_get_project`: Get a specific project in Vercel.
  - `mcp_vercel_get_deployment`: Get a specific deployment by ID or URL.
  - `mcp_vercel_get_deployment_build_logs`: Get the build logs of a deployment by deployment ID or URL.
  - `mcp_vercel_deploy_to_vercel`: Deploy the current project to Vercel
  - `search_replace`: Performs a find and replace operation.
  - `read_lints`: Reads linting errors in a file.
  - `grep`: Searches for a pattern in a file or directory.
  - `todo_write`: Write a todo list.

### SECURITY
- Never read or write `.env` files directly. This includes `.env.local`, `.env.production`, and `.env.staging`.
- Never output the contents of `.env` files or any sensitive configuration files.
- Instead, use the `codebase_search` tool to find relevant information and the `user` to provide the actual API keys or secrets.
- When creating or modifying code, always use parameterized queries to prevent SQL injection attacks.
- Sanitize user input to prevent XSS attacks.
- When using external libraries, carefully review their documentation and security implications.

### STRATEGIC ASSISTANT PROMPT

Here is a strategic assistant prompt to consider:
```
As an AI assistant, focus on creating a clear and maintainable structure for the project, while making sure that the code meets security and data privacy standards. Be prepared to explain the reasoning behind any architectural decisions, and to suggest alternative approaches when necessary.
```

### CODEBASE SEARCH
- When using `codebase_search`, be specific and descriptive in your search query.
- Focus on finding relevant code snippets, data models, or architectural patterns.
- Do not use `codebase_search` to find secrets or API keys.
- If you can't find something with `codebase_search`, ask the user for more information or context.
- Prefer searching specific files or directories over the entire codebase.

### FILE READING & WRITING
- When using `file_read`, be sure to specify the correct file path.
- When using `file_write`, create a new file if necessary.
- When modifying an existing file, be sure to preserve the original formatting and structure.
- Before writing to a file, confirm that you have a clear understanding of the file's purpose and content.
- If you're asked to write an executable script, be sure to set the correct permissions (e.g., `chmod +x`).

### RUN TERMINAL COMMAND
- Use the `run_terminal_cmd` tool to execute terminal commands.
- Be careful when executing commands that could modify the system or data.
- Always confirm with the user before executing destructive commands (e.g., deleting files, dropping databases).
- Only run commands that are necessary to complete the task.
- Do not run commands that could expose secrets or API keys.
- Always run commands one at a time and do not chain them with `&&` or `||`.
- When running commands, always specify the full absolute path to the command.

### MULTI-TOOL USAGE
- Chain multiple tools together to accomplish complex tasks.
- For example, use `codebase_search` to find a file, then use `file_read` to read its content, and then use `file_write` to modify it.
- Use `list_dir` to explore directory structures before attempting to read or write files.

### EXTERNAL API CALLS
- Only make calls to external APIs when necessary.
- Always use a secure HTTPS connection.
- Never include secrets or API keys in the URL.
- Use the appropriate HTTP method (e.g., `GET`, ``POST`, `PUT`, `DELETE`).
- Handle errors gracefully.

### CREATING EXECUTABLE SCRIPTS
- When creating shell scripts, always include a shebang line (`#!/bin/bash`).
- Make the script executable using `chmod +x`.
- Use descriptive variable names.
- Add comments to explain complex logic.
- Test the script thoroughly before using it in production.

### CODE COMMENTS
- Add comments explaining the high-level purpose of functions, classes, and modules.
- Explain complex logic or algorithms in detail.
- Use comments to document the purpose of variables and constants.
- Use comments to explain the expected input and output of functions.
- Use comments to document any known limitations or issues.

### CURSOR RULES
- Adhere to all cursor rules and guidelines.
- Use cursor hooks to enforce project standards and prevent common errors.
- Use cursor snippets to insert code templates.
- Use cursor commands to automate repetitive tasks.
- The `.cursorignore` file blocks `.env` files, but `.env.example` files are allowed with the `!.env.example` rule. To allow creating `.env.local.example`, `.env.staging.example`, and `.env.production.example`, add the following rules to the `.cursorignore` file:
  ```
  !.env.local.example
  !.env.staging.example
  !.env.production.example
  ```

### AI DEVELOPMENT PLAYBOOK
- Follow the AI development playbook for all AI-related tasks.
- Use the appropriate AI models and tools for the task at hand.
- Test AI models thoroughly and validate their performance.
- Document all AI-related code and configurations.

### DOCUMENTATION
- Create documentation for all new code and features.
- Update existing documentation when making changes.
- Use a consistent documentation style.
- Include examples and usage instructions.
- Keep documentation up-to-date.

### CODE CONTRIBUTIONS
- All code contributions should follow the project's coding standards and style guidelines.
- Code should be well-documented and easy to understand.
- All code should be tested thoroughly before being submitted for review.
- Code reviews should be completed in a timely manner.
- All code contributions should be reviewed by at least one other developer before being merged into the main branch.

### ENVIRONMENT MANAGEMENT
- Never hardcode environment-specific values in the codebase.
- Always use environment variables to configure the application.
- Use a consistent naming convention for environment variables.
- Document all environment variables in the `docs/` directory.
- Use separate environment variables for local development, staging, and production.
- Store secrets and API keys securely using a dedicated secrets management system.
- Use a tool like `direnv` to manage environment variables during local development.
- Implement a system for validating environment variables at startup.
- Never store sensitive information in the codebase or in configuration files that are stored in the codebase.
- Follow a 3-environment architecture: Development, Staging, and Production.

### DEPLOYMENT AND INFRASTRUCTURE
- Use Infrastructure-as-Code (IaC) tools to manage infrastructure.
- Automate deployments using CI/CD pipelines.
- Monitor application performance and health using monitoring tools.
- Implement rollback procedures for failed deployments.
- Use a tool like Terraform or CloudFormation to provision infrastructure.
- Automate infrastructure provisioning and configuration.
- Design for scalability and resilience.
- Implement disaster recovery procedures.
- Use a CDN to serve static assets.
- Implement caching to improve performance.

### PRODUCTION SAFETY RULES
- Validate critical configuration on startup.
- Fail loudly and immediately if production requirements are not met.
- Never fall back to mock/test data in production environments.
- Implement environment-specific validation.
- Use different behaviors for development vs production.
- Make production failures impossible to ignore.
- To access your deployed frontend:
  1. Visit the Vercel Dashboard
  2. Navigate to your project
  3. Click on the deployment to access it with proper authentication
  4. Or disable protection if you want public access (in project settings)
- To bypass this for testing:
  1. Log into Vercel in your browser
  2. Access through the dashboard
  3. Or disable protection in project settings if you want public access

### CURSOR RULES
- Adhere to all cursor rules and guidelines.
- Use cursor hooks to enforce project standards and prevent common errors.
- Use cursor snippets to insert code templates.
- Use cursor commands to automate repetitive tasks.

### AI DEVELOPMENT PLAYBOOK
- Follow the AI development playbook for all AI-related tasks.
- Use the appropriate AI models and tools for the task at hand.
- Test AI models thoroughly and validate their performance.
- Document all AI-related code and configurations.

### ENVIRONMENT VALIDATION AND PRODUCTION GUARDS
- The agent service must implement environment validation at startup and production guards.
- The agent service must fail fast in production if required keys are missing or placeholders.
- The agent service must add clear console warnings in non-prod mock modes.
- When the agent service is run in development mode with an invalid API key, it MUST show clear warnings about mock mode with helpful instructions
- The agent service MUST show a warning and helpful instructions for setting the API key when running with an invalid API key in development mode.
- The agent service MUST work normally without warnings with a valid API key.
- The agent service MUST work in production with a valid API key.
- Testing the production safety guards implementation MUST include the following:
    - Missing API Key (Should Fail Fast)
    - Invalid API Key in Production (Should Fail Fast)
    - Placeholder API Key in Production (Should Show Warnings)
    - Invalid API Key in Development (Should Show Warnings)
    - Valid API Key (Should Work Normally)
    - Production with Valid API Key (Should Work)
- The Next.js build process runs in production mode regardless of the `NODE_ENV` environment variable. To allow CI builds to proceed, the production safety check must allow CI builds to proceed by adding a `!process.env.CI` condition.
    - The production safety guard now:
        - Allows CI builds to proceed (CI=true)
        - Still blocks actual production deployments with mock config
        - Maintains security for real production environments
- The agent integration tests must now properly mock the config validation to avoid early `process.exit` calls. The config validation should only run when the test is explicitly validating the configuration.

### ENVIRONMENT CONFIGURATION
- When configuring environment-driven retriever and embedding:
    - Read `RETRIEVER_PROVIDER` and `EMBEDDING_MODEL` from environment variables
    - Set environment-specific defaults:
        - Local/Development: `memory` retriever (fast, no external dependencies)
        - Staging: `pinecone` retriever (production-ready)
        - Production: `pinecone` retriever (production-ready vector store)
- The `appEnv` configuration must be updated to properly handle staging.

### ENVIRONMENT DISCRIMINATORS
- The agent service must add environment discriminators to all vector stores, including Elastic and Pinecone filters.

### GITHUB ACTIONS WORKFLOWS
- When creating GitHub Actions workflows, the trigger for feature branch staging deployments uses the following logic:
  - **Triggers**: The workflow is automatically triggered when code is pushed to any branch that starts with `feat/` or `feature/`.
  - **URL Generation**: The deployment URL is created by taking the branch name (e.g., `feat/new-recipe-search`), replacing `/` with `-` (becomes `feat-new-recipe-search`), and creating the URL: `https://chef-chopsky-git-feat-new-recipe-search.vercel.app`.
- After consolidating to Node.js 20.x, the CI workflow should be updated to reflect this change.
- The "test (20.x)" check in `.github/workflows/ci.yml` should be renamed to `Unit Tests & Build (Node 20)` for a more descriptive name.
- The composite action approach should be used to eliminate duplication in GitHub Actions workflows, creating reusable actions to maintain job independence, faster CI, consistency and easy maintenance.
- **GitHub Actions Checkout Step:** When using local actions in GitHub Actions workflows, always include an `actions/checkout` step before running the local action to ensure that the repository code is available.
    - The `actions/checkout` step MUST be included in the `ci.yml` workflow before running the local action.
    - The local action MUST include `actions/setup-node@v4` and `npm run install:all`.
    - The local action should NOT include `actions/checkout@v4` to avoid duplication and conflicts. The `actions/checkout@v4` step must be called in the CI workflow BEFORE the local action.
- **GitHub Actions CI Build Errors**: When the Next.js build fails in the CI environment due to missing Supabase environment variables, the following steps should be taken:
    - Update `frontend/lib/supabase.ts` to replace assertion operators (`!`) with fallback values. Use placeholder values like `https://placeholder.supabase.co` and `placeholder_key` for CI builds.
    - Add CI-specific environment variables to the `.github/workflows/ci.yml` workflow file. These include:
        - `NEXT_PUBLIC_SUPABASE_URL: https://placeholder.supabase.co`
        - `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY: placeholder_key`
        - `SUPABASE_SECRET_KEY: placeholder_secret`
        - `AGENT_SERVICE_URL: http://localhost:3001`
        - `NEXT_PUBLIC_APP_ENV: ci`
        - `APP_ENV: ci`
    - Ensure that the production safety guards and mock mode detection still work as intended.
- **Disabling GitHub Actions Workflows:** To temporarily disable GitHub Actions workflows, comment out the `on:` section in the workflow file. This prevents the workflow from running on push/PR events while debugging or developing. Remember to re-enable the workflow by uncommenting the `on:` section when finished.
- **Supabase CLI Installation**: The recommended method for installing the Supabase CLI in CI environments is to download the pre-built binary using `curl`, extract it, and move it to `/usr/local/bin/`.
    - Example:
    ```bash
    curl -fsSL https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar -xz
    sudo mv supabase /usr/local/bin/
    supabase --version
    ```
- **GitHub Actions CI Workflow - Checkout and Local Action:** When using local actions in GitHub Actions workflows, always include an `actions/checkout` step before running the local action to ensure that the repository code is available.
    - The `actions/checkout` step MUST be included in the `ci.yml` workflow before running the local action.
    - The local action MUST include `actions/setup-node@v4` and `npm run install:all`.
    - The local action should NOT include `actions/checkout@v4` to avoid duplication and conflicts. The `actions/checkout@v4` step must be called in the CI workflow BEFORE the local action.
- **GitHub Actions Workflow - Correct Supabase CLI Binary for Linux**: The CI workflow must use the correct Supabase CLI binary for Linux (Ubuntu runners):
    ```bash
    # Install using the recommended method for CI (Linux binary for Ubuntu runners)
    curl -fsSL https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar -xz
    sudo mv supabase /usr/local/bin/
    ```

### RAILWAY CONFIGURATION AND ENVIRONMENT VARIABLES
- **Separate Railway Projects for Environments:** Production and staging environments MUST use separate Railway projects to ensure complete isolation of configurations and data.
- **Staging Environment Variables:** When configuring the staging environment in Railway:
    - `LANGCHAIN_PROJECT` MUST be set to `chef-chopsky-staging`
    - `APP_ENV` MUST be set to `staging`
    - `NODE_ENV` MUST be set to `staging`
    - `LANGCHAIN_INDEX_NAME` MUST be set to `chef-chopsky-staging`
- **Railway Service Names:**
    - The production Railway service is named `chef-chopsky-production`.
    - A separate Railway service MUST be created for staging and named `chef-chopsky-staging`.

### ENVIRONMENT FILES
- When creating or updating environment files, ensure the following files exist and are up to date for both the `@frontend/` and `@agent/` directories:
  - `.env.example`: Core template with essential variables needed across all environments.
  - `.env.local.example`: Local development configuration
  - `.env.staging.example`: Staging environment configuration
  - `.env.production.example`: Production environment configuration

### PINECONE ENVIRONMENT VARIABLE
- The `PINECONE_ENVIRONMENT` variable specifies the environment for your Pinecone project. To find this value:
    1. **Access the Pinecone Console**: Log in to your Pinecone account at [https://app.pinecone.io](https://app.pinecone.io).
    2. **Navigate to the API Keys Section**: In the console, click on the "API Keys" tab on the left-hand side.
    3. **Locate Your Environment**: Here, you'll find your API keys along with the corresponding environment for each key. The environment is typically a string like `us-east-1-aws` or `gcp-starter`.
    4. **Serverless Pinecone Indexes**: If you're using a Serverless Pinecone index, the concept of "environment" has been replaced with "region." In this case, you should use the region value instead of the environment. For more details, refer to Pinecone's [Authentication Documentation](https://docs.pinecone.io/reference/api/authentication). If you're using a Serverless Pinecone index, you might not need `PINECONE_ENVIRONMENT` at all.
    5. **Pod-based Pinecone Indexes**: For older, pod-based Pinecone indexes, you'll need both `PINECONE_API_KEY` and `PINECONE_ENVIRONMENT`. The environment corresponds to the cloud provider and region where your index is hosted.
    6. **Example Values**: Your `.env.production.example` should look like:
        ```bash
        PINECONE_API_KEY=your_production_pinecone_api_key_here
        PINECONE_ENVIRONMENT=us-east-1-aws  # or whatever your environment shows
        ```
    7. **Troubleshooting**:
        - Make sure you're using the latest Pinecone SDK.
        - Check if you're using Serverless indexes (which might not require environment).
        - Contact Pinecone support if you're still having issues.

### CURSOR RULES
- The `.cursorignore` file blocks `.env` files, but `.env.example` files are allowed with the `!.env.example` rule. To allow creating `.env.local.example`, `.env.staging.example`, and `.env.production.example`, add the following rules to the `.cursorignore` file:
  ```
  !.env.local.example
  !.env.staging.example
  !.env.production.example
  ```

### TESTING
- Before merging a pull request, run as many checks as possible locally against the branch and staging. This includes:
    - Running agent tests that are failing in GitHub
    - Running frontend tests (Node 20.x) that are failing
    - Running health checks and environment separation tests
    - Running staging deployment validation
    - Running CI checks including security and integration tests
    - Fixing any issues found during local testing.
- When running agent tests locally, be aware that some tests are designed to trigger production safety guards when running with production configurations but invalid API keys. These "failing" tests are actually verifying that the guards are working correctly.
- **90% of your integration tests should use REAL SERVICES.**
- Mock only:
    - External services (LangSmith, third-party APIs).
    - React components (for unit testing).
    - Services that are intentionally unavailable in the test environment.
- Never mock:
    - Your own database operations
    - Your own API endpoints
    - Your own service communication
    - Core business logic
- **For E2E tests**
  - They are configured to run in **multiple environments** with different configurations:
  1.  LOCAL Environment
      *   File: `playwright.config.ts`
      *   Base URL: `http://localhost:3000`
      *   Agent URL: `http://localhost:3001`
      *   Services: Auto-started via `webServer` configuration
      *   Commands:
          *   `npm run test:e2e` - Run E2E tests locally
          *   `npm run test:e2e:ui` - Run with Playwright UI
          *   `npm run test:e2e:headed` - Run in headed mode
  2.  PRODUCTION Environment
      *   File: `playwright.production.config.ts`
      *   Base URL: `https://chef-chopsky-production.vercel.app`
      *   Agent URL: `https://chef-chopsky-production.up.railway.app`
      *   Services: External (no local servers)
      *   Commands:
          *   `npm run test:e2e:production` - Run production E2E tests
          *   `npm run test:e2e:production:headed` - Run in headed mode
      *   Test Files:
          *   `production-tests.spec.ts` - Production-specific tests
          *   Uses `ProductionTestEnvironment` for setup
  3.  CI/CD Environment (GitHub Actions)
      *   File: `.github/workflows/ci.yml`
      *   Base URL: `http://localhost:3000` (services started in CI)
      *   Environment: Ubuntu runners with service orchestration
      *   Service Orchestration:
          *   Services are started via `start-services.sh`
          *   Health checks ensure services are ready
          *   Tests run against localhost services in CI
- Tests automatically detect their environment through:
    1.  CI Environment Variable:
    2.  Base URL Configuration:
    3.  Service Health Checks:
- E2E tests automatically detect their environment through:
    1.  Configuration file used (`playwright.config.ts` vs `playwright.production.config.ts`)
    2.  Command executed (`test:e2e` vs `test:e2e:production`)
    3.  CI environment detection (`process.env.CI`)
- When running E2E tests locally, they should use as "real" code and tools as possible. For example, local E2E tests should use a real Supabase backend and Langsmith. To achieve this:
  - Keep using the current hosted Supabase setup for E2E tests initially. This provides real database operations immediately without additional setup.
  - Implement Local Supabase CLI tasks for a better local

### GITHUB CHECKS EXPLAINED

This document provides plain English explanations of the GitHub workflow files, their triggers, checks, importance, and priority.

| Workflow File                                      | Triggers                                                                                                                                                                                                                                   | What It Does                                                                                                                                      | Checks                                                                                                                                                                                                                   | Why Important                                                                                                                                                  | Priority |
| :------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------- |
| `ci.yml`                                           | `pull_request` (on every pull request); `push` (on every push to any branch)                                                                                                                                                             | Runs core continuous integration checks to validate code quality and compatibility.                                                               | `CI / Code Quality: Lint, Tests, Build`: Runs linters, unit and integration tests, and builds using Node.js 20.x. `CI / security`: Scans code for security vulnerabilities. | Ensures the codebase is stable, secure, and compatible with Node.js 20.x. Catches basic issues early.                                       | High     |
| `test-agent.yml`                                     | `pull_request` (on every pull request)                                                                                                                                                                                                     | Runs tests specifically for the Chef Chopsky Agent service (the AI backend).                                                                      | `Test Chef Chopsky Agent / test-agent`: Executes all tests for the agent service.                                                                                                                               | Verifies the AI backend is functioning correctly and there are no regressions in functionality.                                                           | High     |
| `health-checks-and-environment-separation-tests.yml` | `pull_request` (on every pull request)                                                                                                                                                                                                     | Validates the health and environment isolation of different deployment environments.                                                                | `Health Checks and Environment Separation Tests / health-checks`: Tests that all services are running and responding to health check endpoints. `Health Checks and Environment Separation Tests / environment-separation`: Verifies that different environments are properly isolated. | Ensures services are running and environments are correctly configured, preventing cross-contamination and promoting stability.                              | Medium   |
| `staging-deployment.yml`                             | `push` (on branches that start with `feat/` or `feature/`)                                                                                                                                                                                  | Deploys the application to the staging environment for testing and validation of new features.                                                    | `Staging Deployment / validate`: Validates the staging environment configuration and setup. `Staging Deployment / deploy-agent`: Deploys the agent service to staging. `Staging Deployment / deploy-frontend`: Deploys the frontend to staging. `Staging Deployment / post-deployment-tests`: Runs tests after deployment. | Provides a realistic testing environment for new features before they are released to production. Ensures that deployments are automated and reliable. | Medium   |
| `production-deployment.yml`                          | Manual trigger (workflow_dispatch)                                                                                                                                                                                                   | Manually deploys the application to the production environment after thorough testing and validation.                                               | `Vercel – chef-chopsky-production`: Attempts to deploy the application to the production environment on Vercel.                                                                                               | Releases a stable and validated version of the application to end-users.                                                                                   | High     |
| `pr-validation.yml`                                  | `pull_request` (on every pull request)                                                                                                                                                                                                     | Runs basic validations to ensure code quality and security before merging a pull request.                                                              | `CI / security`: Scans code for security vulnerabilities. `CI / Code Quality: Lint, Tests, Build`: Runs linters, unit and integration tests using Node.js 20.x.      | Catches basic issues early and prevents broken code from being merged into the main branch.                                                                   | High     |
| `deployment-monitoring.yml`                           | `workflow_run` (on completion of deployment workflows)                                                                                                                                                                             | Monitors deployments and sends notifications about their status.                                                                                 | (This workflow primarily handles notifications and doesn't have direct "checks" in the same sense as the others.)                                                                                               | Provides visibility into the deployment process and ensures that stakeholders are informed of any issues.                                                     | Low      |
| `deployment-notifications.yml`                         | `workflow_run` (on completion of deployment workflows)                                                                                                                                                                             | Sends notifications about the deployment status, such as success or failure.                                                                    | (This workflow primarily handles notifications and doesn't have direct "checks" in the same sense as the others.)                                                                                               | Provides visibility into the deployment process and ensures that stakeholders are informed of any issues.                                                     | Low      |
| `sync-production-env.yml`                             | Manual trigger (workflow_dispatch)                                                                                                                                                                                                   | Synchronizes environment variables between different environments.                                                                                 | (This workflow primarily handles environment variable syncing and doesn't have direct "checks" in the same sense as the others.)                                                                                | Ensures that the correct environment variables are configured in all environments.                                                                           | Medium   |
| `auto-fix-ci.yml`/`auto-fix-ci-alternative.yml`       | `pull_request` (on every pull request)                                                                                                                                                                                                     | Attempts to automatically fix common CI issues.                                                                                                 | (These workflows attempt to automatically fix issues and don't have direct "checks" in the same sense as the others.)                                                                                              | Reduces the burden on developers by automatically fixing common problems.                                                                                     | Low      |
| `staging-validation.yml`                               | `push` (on branches that start with `main` or `develop`); `pull_request` (on branches that target `main` or `develop`)                                                                                                               | Runs E2E tests against the live staging environment.                                                                                             | `Staging E2E Tests`: Executes end-to-end tests on the staging environment.                                                                                                                                   | Validates the stability and functionality of the staging environment before merging changes into production.                                               | Medium   |
+
 ## Checks vs Triggers
 
 Here’s a quick, high‑signal matrix of what runs when. Checks are rows; triggers are columns. A ✓ means that check runs for that trigger in this repo today.

Triggers:
- PR(main/develop): pull requests targeting main or develop
- PR(agent/main|master): pull requests that touch agent/ and target main/master (test-agent workflow)
- Push(main/develop): direct pushes to main or develop
- Push(staging): pushes to staging
- Push(feat/*): pushes to feature branches (feat/* or feature/*)
- Schedule: hourly cron health checks
- Manual: workflow_dispatch buttons

Checks vs Triggers

| Check type                               | PR(main/ develop) | PR(agent/ main|master) | Push(main/ develop) | Push(staging) | Push(feat/*) | Schedule | Manual |
|------------------------------------------|-------------------:|-----------------------:|---------------------:|--------------:|-------------:|---------:|-------:|
| Linting (repo-wide)                      | ✓ (CI/validate)    | –                      | ✓ (CI)               | ✓ (validate)  |