---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

*   **Environment Workflow and Testing Strategy:** Document the environment workflow, explaining the purpose of each environment (Development, Preview, Staging, and Production), the testing strategy for each, and the overall deployment workflow. Include environment-specific configurations and a cost-effective approach using free tiers.
*   **Staging Setup Guide:** Update the staging setup guide to reflect the separate Vercel project approach instead of using Vercel's built-in environment functionality. This includes architectural changes and step-by-step instructions for creating a separate staging project.
*   **Local Supabase via CLI:** Adopt Supabase CLI for local development database (Docker-based). Add `npm run supabase:start`/`supabase:stop` scripts and docs. Create `frontend/.env.local.example` pointing to local Supabase URL/anon key. Document migrations flow: `npx supabase db reset` for local; `db push` for staging/prod. Document environment mapping: Local (CLI) | Staging (hosted `chef-chopsky-staging`) | Production (hosted `chef-chopsky`). Note: the previous `chef-chopsky-local` hosted project has been repurposed as the staging project to stay within free tier limits

## TECH STACK

## CODING STANDARDS

## WORKFLOW & RELEASE RULES

*   **Vercel Environment Variables:** When setting environment variables in Vercel projects, the separate staging project approach uses the "production" environment type for the staging project. This is done to stay within free tier limits. This may impact the commands used to sync environment variables.
*   **Syncing Vercel Environment Variables:** The `sync-vercel-env.sh` script can be used to sync environment variables. The separate staging project uses the "production" environment type, so the command should be run with the `--environment production` flag.
    *   When syncing environment variables for the staging environment, first navigate to the frontend directory (`cd frontend`). Then, link the Vercel project (`vercel link --yes --project chef-chopsky-staging`). Finally, run the sync script from the parent directory (`cd ..; ./scripts/sync-vercel-env.sh --file frontend/.env.staging --environment production`).
*   **Feature Branch Staging Deployments**: The trigger for feature branch staging deployments uses the following logic:
    *   **Triggers**: The workflow is automatically triggered when code is pushed to any branch that starts with `feat/` or `feature/`.
    *   **URL Generation**: The deployment URL is created by taking the branch name (e.g., `feat/new-recipe-search`), replacing `/` with `-` (becomes `feat-new-recipe-search`), and creating the URL: `https://chef-chopsky-git-feat-new-recipe-search.vercel.app`.

## DEBUGGING

*   **Staging vs Production Supabase Credentials:** If staging writes are appearing in production, it's likely that the Vercel environment variables for both staging and production are linked to the same Supabase project. The `NEXT_PUBLIC_SUPABASE_URL` and keys should be different for each environment. To fix this:
    *   In Vercel, for the `chef-chopsky-staging` project, set `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY` to your STAGING project values and `SUPABASE_SECRET_KEY` to the STAGING service role key.
    *   In Vercel, for the `chef-chopsky` (production) project, ensure those three env vars are production values only.
    *   Redeploy both projects after saving changes.

## AI CODING ASSISTANT RULES

### GENERAL BEHAVIOR
- You are an expert software engineer.
- Follow instructions precisely and completely.
- Ask clarifying questions before proceeding if instructions are ambiguous.
- Generate high-quality, well-documented code.
- Adhere to project standards and best practices.
- Focus on solving the user's problem efficiently and effectively.
- Use the tools available to you to gather information and complete tasks.
- Never expose secrets or API keys in the codebase or in any generated text.
- Use `docs/` to learn about architectural decisions, API usage, and data models.
- Use comments to explain complex code.
- Use descriptive variable names.
- Keep code DRY (Don't Repeat Yourself).
- Acknowledge all steps.

### TOOLS
- You have access to the following tools:
  - `codebase_search`: Search the codebase for relevant information.
  - `file_read`: Read the content of a file.
  - `file_write`: Write content to a file.
  - `file_delete`: Delete a file.
  - `mcp_cursor-playwright_browser_snapshot`: Take a screenshot of the browser.
  - `mcp_cursor-playwright_browser_console_messages`: Returns all console messages.
  - `mcp_cursor-playwright_browser_click`: Perform click on a web page
  - `mcp_cursor-playwright_browser_type`: Type text into editable element
  - `mcp_cursor-playwright_browser_wait_for`: Wait for text to appear or disappear or a specified time to pass
  - `mcp_Railway_get-logs`: Get the logs of a Railway service.
  - `mcp_Railway_list-variables`: List Railway environment variables.
  - `mcp_Railway_check-railway-status`: Check if Railway CLI is installed and user is logged in.
  - `mcp_Railway_set-variables`: Set environment variables for a Railway service.
  - `run_terminal_cmd`: Execute a terminal command.
  - `apply_patch`: Apply a patch to a file.
  - `web_search`: Web search for relevant information (e.g., library documentation, usage examples).
  - `list_dir`: List the files in a directory.
  - `glob_file_search`: Search for files matching a glob pattern.
  - `fetch_rules`: Fetch the active rules.
  - `mcp_vercel_list_teams`: List the user's teams.
  - `mcp_vercel_list_projects`: List all Vercel projects for a user.
  - `mcp_vercel_get_project`: Get a specific project in Vercel.
  - `mcp_vercel_get_deployment`: Get a specific deployment by ID or URL.
  - `mcp_vercel_get_deployment_build_logs`: Get the build logs of a deployment by deployment ID or URL.
  - `mcp_vercel_deploy_to_vercel`: Deploy the current project to Vercel
  - `search_replace`: Performs a find and replace operation.
  - `read_lints`: Reads linting errors in a file.
  - `grep`: Searches for a pattern in a file or directory.

### SECURITY
- Never read or write `.env` files directly. This includes `.env.local`, `.env.production`, and `.env.staging`.
- Never output the contents of `.env` files or any sensitive configuration files.
- Instead, use the `codebase_search` tool to find relevant information and the `user` to provide the actual API keys or secrets.
- When creating or modifying code, always use parameterized queries to prevent SQL injection attacks.
- Sanitize user input to prevent XSS attacks.
- When using external libraries, carefully review their documentation and security implications.

### STRATEGIC ASSISTANT PROMPT

Here is a strategic assistant prompt to consider:
```
As an AI assistant, focus on creating a clear and maintainable structure for the project, while making sure that the code meets security and data privacy standards. Be prepared to explain the reasoning behind any architectural decisions, and to suggest alternative approaches when necessary.
```

### CODEBASE SEARCH
- When using `codebase_search`, be specific and descriptive in your search query.
- Focus on finding relevant code snippets, data models, or architectural patterns.
- Do not use `codebase_search` to find secrets or API keys.
- If you can't find something with `codebase_search`, ask the user for more information or context.
- Prefer searching specific files or directories over the entire codebase.

### FILE READING & WRITING
- When using `file_read`, be sure to specify the correct file path.
- When using `file_write`, create a new file if necessary.
- When modifying an existing file, be sure to preserve the original formatting and structure.
- Before writing to a file, confirm that you have a clear understanding of the file's purpose and content.
- If you're asked to write an executable script, be sure to set the correct permissions (e.g., `chmod +x`).

### RUN TERMINAL COMMAND
- Use the `run_terminal_cmd` tool to execute terminal commands.
- Be careful when executing commands that could modify the system or data.
- Always confirm with the user before executing destructive commands (e.g., deleting files, dropping databases).
- Only run commands that are necessary to complete the task.
- Do not run commands that could expose secrets or API keys.
- Always run commands one at a time and do not chain them with `&&` or `||`.
- When running commands, always specify the full absolute path to the command.

### MULTI-TOOL USAGE
- Chain multiple tools together to accomplish complex tasks.
- For example, use `codebase_search` to find a file, then use `file_read` to read its content, and then use `file_write` to modify it.
- Use `list_dir` to explore directory structures before attempting to read or write files.

### EXTERNAL API CALLS
- Only make calls to external APIs when necessary.
- Always use a secure HTTPS connection.
- Never include secrets or API keys in the URL.
- Use the appropriate HTTP method (e.g., `GET`, `POST`, `PUT`, `DELETE`).
- Handle errors gracefully.

### CREATING EXECUTABLE SCRIPTS
- When creating shell scripts, always include a shebang line (`#!/bin/bash`).
- Make the script executable using `chmod +x`.
- Use descriptive variable names.
- Add comments to explain complex logic.
- Test the script thoroughly before using it in production.

### CODE COMMENTS
- Add comments explaining the high-level purpose of functions, classes, and modules.
- Explain complex logic or algorithms in detail.
- Use comments to document the purpose of variables and constants.
- Use comments to explain the expected input and output of functions.
- Use comments to document any known limitations or issues.

### CURSOR RULES
- Adhere to all cursor rules and guidelines.
- Use cursor hooks to enforce project standards and prevent common errors.
- Use cursor snippets to insert code templates.
- Use cursor commands to automate repetitive tasks.
- The `.cursorignore` file blocks `.env` files, but `.env.example` files are allowed with the `!.env.example` rule. To allow creating `.env.local.example`, `.env.staging.example`, and `.env.production.example`, add the following rules to the `.cursorignore` file:
  ```
  !.env.local.example
  !.env.staging.example
  !.env.production.example
  ```

### AI DEVELOPMENT PLAYBOOK
- Follow the AI development playbook for all AI-related tasks.
- Use the appropriate AI models and tools for the task at hand.
- Test AI models thoroughly and validate their performance.
- Document all AI-related code and configurations.

### DOCUMENTATION
- Create documentation for all new code and features.
- Update existing documentation when making changes.
- Use a consistent documentation style.
- Include examples and usage instructions.
- Keep documentation up-to-date.

### CODE CONTRIBUTIONS
- All code contributions should follow the project's coding standards and style guidelines.
- Code should be well-documented and easy to understand.
- All code should be tested thoroughly before being submitted for review.
- Code reviews should be completed in a timely manner.
- All code contributions should be reviewed by at least one other developer before being merged into the main branch.

### ENVIRONMENT MANAGEMENT
- Never hardcode environment-specific values in the codebase.
- Always use environment variables to configure the application.
- Use a consistent naming convention for environment variables.
- Document all environment variables in the `docs/` directory.
- Use separate environment variables for local development, staging, and production.
- Store secrets and API keys securely using a dedicated secrets management system.
- Use a tool like `direnv` to manage environment variables during local development.
- Implement a system for validating environment variables at startup.
- Never store sensitive information in the codebase or in configuration files that are stored in the codebase.
- Follow a 3-environment architecture: Development, Staging, and Production.

### DEPLOYMENT AND INFRASTRUCTURE
- Use Infrastructure-as-Code (IaC) tools to manage infrastructure.
- Automate deployments using CI/CD pipelines.
- Monitor application performance and health using monitoring tools.
- Implement rollback procedures for failed deployments.
- Use a tool like Terraform or CloudFormation to provision infrastructure.
- Automate infrastructure provisioning and configuration.
- Design for scalability and resilience.
- Implement disaster recovery procedures.
- Use a CDN to serve static assets.
- Implement caching to improve performance.

### PRODUCTION SAFETY RULES
- Validate critical configuration on startup.
- Fail loudly and immediately if production requirements are not met.
- Never fall back to mock/test data in production environments.
- Implement environment-specific validation.
- Use different behaviors for development vs production.
- Make production failures impossible to ignore.
- To access your deployed frontend:
  1. Visit the Vercel Dashboard
  2. Navigate to your project
  3. Click on the deployment to access it with proper authentication
  4. Or disable protection if you want public access (in project settings)
- To bypass this for testing:
  1. Log into Vercel in your browser
  2. Access through the dashboard
  3. Or disable protection in project settings if you want public access

### CURSOR RULES
- Adhere to all cursor rules and guidelines.
- Use cursor hooks to enforce project standards and prevent common errors.
- Use cursor snippets to insert code templates.
- Use cursor commands to automate repetitive tasks.

### AI DEVELOPMENT PLAYBOOK
- Follow the AI development playbook for all AI-related tasks.
- Use the appropriate AI models and tools for the task at hand.
- Test AI models thoroughly and validate their performance.
- Document all AI-related code and configurations.

### ENVIRONMENT VALIDATION AND PRODUCTION GUARDS
- The agent service must implement environment validation at startup and production guards.
- The agent service must fail fast in production if required keys are missing or placeholders.
- The agent service must add clear console warnings in non-prod mock modes.
- When the agent service is run in development mode with an invalid API key, it MUST show clear warnings about mock mode with helpful instructions
- The agent service MUST show a warning and helpful instructions for setting the API key when running with an invalid API key in development mode.
- The agent service MUST work normally without warnings with a valid API key.
- The agent service MUST work in production with a valid API key.
- Testing the production safety guards implementation MUST include the following:
    - Missing API Key (Should Fail Fast)
    - Invalid API Key in Production (Should Fail Fast)
    - Placeholder API Key in Production (Should Show Warnings)
    - Invalid API Key in Development (Should Show Warnings)
    - Valid API Key (Should Work Normally)
    - Production with Valid API Key (Should Work)

### ENVIRONMENT CONFIGURATION
- When configuring environment-driven retriever and embedding:
    - Read `RETRIEVER_PROVIDER` and `EMBEDDING_MODEL` from environment variables
    - Set environment-specific defaults:
        - Local/Development: `memory` retriever (fast, no external dependencies)
        - Staging: `pinecone` retriever (production-ready)
        - Production: `pinecone` retriever (production-ready vector store)
- The `appEnv` configuration must be updated to properly handle staging.

### ENVIRONMENT DISCRIMINATORS
- The agent service must add environment discriminators to all vector stores, including Elastic and Pinecone filters.

### GITHUB ACTIONS WORKFLOWS
- When creating GitHub Actions workflows, the trigger for feature branch staging deployments uses the following logic:
  - **Triggers**: The workflow is automatically triggered when code is pushed to any branch that starts with `feat/` or `feature/`.
  - **URL Generation**: The deployment URL is created by taking the branch name (e.g., `feat/new-recipe-search`), replacing `/` with `-` (becomes `feat-new-recipe-search`), and creating the URL: `https://chef-chopsky-git-feat-new-recipe-search.vercel.app`.

### RAILWAY CONFIGURATION AND ENVIRONMENT VARIABLES
- **Separate Railway Projects for Environments:** Production and staging environments MUST use separate Railway projects to ensure complete isolation of configurations and data.
- **Staging Environment Variables:** When configuring the staging environment in Railway:
    - `LANGCHAIN_PROJECT` MUST be set to `chef-chopsky-staging`
    - `APP_ENV` MUST be set to `staging`
    - `NODE_ENV` MUST be set to `staging`
    - `LANGCHAIN_INDEX_NAME` MUST be set to `chef-chopsky-staging`
- **Railway Service Names:**
    - The production Railway service is named `chef-chopsky`.
    - A separate Railway service MUST be created for staging and named `chef-chopsky-staging`.

### ENVIRONMENT FILES
- When creating or updating environment files, ensure the following files exist and are up to date for both the `@frontend/` and `@agent/` directories:
  - `.env.example`: Core template with essential variables needed across all environments.
  - `.env.local.example`: Local development configuration
  - `.env.staging.example`: Staging environment configuration
  - `.env.production.example`: Production environment configuration

### PINECONE ENVIRONMENT VARIABLE
- The `PINECONE_ENVIRONMENT` variable specifies the environment for your Pinecone project. To find this value:
    1. **Access the Pinecone Console**: Log in to your Pinecone account at [https://app.pinecone.io](https://app.pinecone.io).
    2. **Navigate to the API Keys Section**: In the console, click on the "API Keys" tab on the left-hand side.
    3. **Locate Your Environment**: Here, you'll find your API keys along with the corresponding environment for each key. The environment is typically a string like `us-east-1-aws` or `gcp-starter`.
    4. **Serverless Pinecone Indexes**: If you're using a Serverless Pinecone index, the concept of "environment" has been replaced with "region." In this case, you should use the region value instead of the environment. For more details, refer to Pinecone's [Authentication Documentation](https://docs.pinecone.io/reference/api/authentication). If you're using a Serverless Pinecone index, you might not need `PINECONE_ENVIRONMENT` at all.
    5. **Pod-based Pinecone Indexes**: For older, pod-based Pinecone indexes, you'll need both `PINECONE_API_KEY` and `PINECONE_ENVIRONMENT`. The environment corresponds to the cloud provider and region where your index is hosted.
    6. **Example Values**: Your `.env.production.example` should look like:
        ```bash
        PINECONE_API_KEY=your_production_pinecone_api_key_here
        PINECONE_ENVIRONMENT=us-east-1-aws  # or whatever your environment shows
        ```
    7. **Troubleshooting**:
        - Make sure you're using the latest Pinecone SDK.
        - Check if you're using Serverless indexes (which might not require environment).
        - Contact Pinecone support if you're still having issues.

### CURSOR RULES
- The `.cursorignore` file blocks `.env` files, but `.env.example` files are allowed with the `!.env.example` rule. To allow creating `.env.local.example`, `.env.staging.example`, and `.env.production.example`, add the following rules to the `.cursorignore` file:
  ```
  !.env.local.example
  !.env.staging.example
  !.env.production.example
  ```

### TESTING
- Before merging a pull request, run as many checks as possible locally against the branch and staging. This includes:
    - Running agent tests that are failing in GitHub
    - Running frontend tests (Node 20.x) that are failing
    - Running health checks and environment separation tests
    - Running staging deployment validation
    - Running CI checks including security and integration tests
    - Fixing any issues found during local testing.
- When running agent tests locally, be aware that some tests are designed to trigger production safety guards when running with production configurations but invalid API keys. These "failing" tests are actually verifying that the guards are working correctly.

### GITHUB CHECKS EXPLAINED

This document provides plain English explanations of the GitHub workflow files, their triggers, checks, importance, and priority.

| Workflow File                                      | Triggers                                                                                                                                                                                                                                   | What It Does                                                                                                                                      | Checks                                                                                                                                                                                                                   | Why Important                                                                                                                                                  | Priority |
| :------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------- |
| `ci.yml`                                           | `pull_request` (on every pull request); `push` (on every push to any branch)                                                                                                                                                             | Runs core continuous integration checks to validate code quality and compatibility.                                                               | `CI / test (18.x)`: Runs unit and integration tests using Node.js 18.x. `CI / test (20.x)`: Runs unit and integration tests using Node.js 20.x. `CI / security`: Scans code for security vulnerabilities. | Ensures the codebase is stable, secure, and compatible across different Node.js versions. Catches basic issues early.                                       | High     |
| `test-agent.yml`                                     | `pull_request` (on every pull request)                                                                                                                                                                                                     | Runs tests specifically for the Chef Chopsky Agent service (the AI backend).                                                                      | `Test Chef Chopsky Agent / test-agent`: Executes all tests for the agent service.                                                                                                                               | Verifies the AI backend is functioning correctly and there are no regressions in functionality.                                                           | High     |
| `health-checks-and-environment-separation-tests.yml` | `pull_request` (on every pull request)                                                                                                                                                                                                     | Validates the health and environment isolation of different deployment environments.                                                                | `Health Checks and Environment Separation Tests / health-checks`: Tests that all services are running and responding to health check endpoints. `Health Checks and Environment Separation Tests / environment-separation`: Verifies that different environments are properly isolated. | Ensures services are running and environments are correctly configured, preventing cross-contamination and promoting stability.                              | Medium   |
| `staging-deployment.yml`                             | `push` (on branches that start with `feat/` or `feature/`)                                                                                                                                                                                  | Deploys the application to the staging environment for testing and validation of new features.                                                    | `Staging Deployment / validate`: Validates the staging environment configuration and setup. `Staging Deployment / deploy-agent`: Deploys the agent service to staging. `Staging Deployment / deploy-frontend`: Deploys the frontend to staging. `Staging Deployment / post-deployment-tests`: Runs tests after deployment. | Provides a realistic testing environment for new features before they are released to production. Ensures that deployments are automated and reliable. | Medium   |
| `production-deployment.yml`                          | Manual trigger (workflow_dispatch)                                                                                                                                                                                                   | Manually deploys the application to the production environment after thorough testing and validation.                                               | `Vercel – chef-chopsky-production`: Attempts to deploy the application to the production environment on Vercel.                                                                                               | Releases a stable and validated version of the application to end-users.                                                                                   | High     |
| `pr-validation.yml`                                  | `pull_request` (on every pull request)                                                                                                                                                                                                     | Runs basic validations to ensure code quality and security before merging a pull request.                                                              | `CI / security`: Scans code for security vulnerabilities. `CI / test (18.x)`: Runs unit and integration tests using Node.js 18.x. `CI / test (20.x)`: Runs unit and integration tests using Node.js 20.x.      | Catches basic issues early and prevents broken code from being merged into the main branch.                                                                   | High     |
| `deployment-monitoring.yml`                           | `workflow_run` (on completion of deployment workflows)                                                                                                                                                                             | Monitors deployments and sends notifications about their status.                                                                                 | (This workflow primarily handles notifications and doesn't have direct "checks" in the same sense as the others.)                                                                                               | Provides visibility into the deployment process and ensures that stakeholders are informed of any issues.                                                     | Low      |
| `deployment-notifications.yml`                         | `workflow_run` (on completion of deployment workflows)                                                                                                                                                                             | Sends notifications about the deployment status, such as success or failure.                                                                    | (This workflow primarily handles notifications and doesn't have direct "checks" in the same sense as the others.)                                                                                               | Provides visibility into the deployment process and ensures that stakeholders are informed of any issues.                                                     | Low      |
| `sync-production-env.yml`                             | Manual trigger (workflow_dispatch)                                                                                                                                                                                                   | Synchronizes environment variables between different environments.                                                                                 | (This workflow primarily handles environment variable syncing and doesn't have direct "checks" in the same sense as the others.)                                                                                | Ensures that the correct environment variables are configured in all environments.                                                                           | Medium   |
| `auto-fix-ci.yml`/`auto-fix-ci-alternative.yml`       | `pull_request` (on every pull request)                                                                                                                                                                                                     | Attempts to automatically fix common CI issues.                                                                                                 | (These workflows attempt to automatically fix issues and don't have direct "checks" in the same sense as the others.)                                                                                              | Reduces the burden on developers by automatically fixing common problems.                                                                                     | Low      |

Here’s a quick, high‑signal matrix of what runs when. Checks are rows; triggers are columns. A ✓ means that check runs for that trigger in this repo today.

Triggers:
- PR(main/develop): pull requests targeting main or develop
- PR(agent/main|master): pull requests that touch agent/ and target main/master (test-agent workflow)
- Push(main/develop): direct pushes to main or develop
- Push(staging): pushes to staging
- Push(feat/*): pushes to feature branches (feat/* or feature/*)
- Schedule: hourly cron health checks
- Manual: workflow_dispatch buttons

Checks vs Triggers

| Check type                               | PR(main/ develop) | PR(agent/ main|master) | Push(main/ develop) | Push(staging) | Push(feat/*) | Schedule | Manual |
|------------------------------------------|-------------------:|-----------------------:|---------------------:|--------------:|-------------:|---------:|-------:|
| Linting (repo-wide)                      | ✓ (CI/validate)    | –                      | ✓ (CI)               | ✓ (validate)  | ✓ (CI)      | –       | –     |
| Type-check (build TS in CI)              | ✓ (build steps)    | ✓ (agent build)        | ✓ (build steps)      | ✓ (build)     | ✓ (build)   | –       | –     |
| Build (frontend + agent)                 | ✓                  | ✓ (agent)              | ✓                    | ✓             | ✓            | –       | –     |
| Unit tests – Frontend                    | ✓                  | –                      | ✓                    | ✓             | ✓            | –       | –     |
| Unit tests – Agent                       | ✓                  | ✓                      | ✓                    | ✓             | ✓            | –       | –     |
| Integration tests – Frontend             | ✓ (CI integration) | –                      | ✓ (CI integration)   | ✓ (validate)  | ✓ (CI)      | –       | –     |
| Integration tests – Agent                | ✓ (CI integration) | ✓ (in test-agent)      | ✓ (CI integration)   | ✓ (validate)  | ✓ (CI)      | –       | –     |
| E2E tests – Playwright (frontend)        | ✓ (CI integration) | –                      | ✓ (CI integration)   | ✓ (post-deploy)| ✓ (CI)     | –       | –     |
| High‑value integration (fast critical)   | ✓                  | –                      | ✓                    | –             | ✓            | –       | –     |
| Security audit (npm audit)               | ✓                  | –                      | ✓                    | ✓ (validate)  | ✓            | –       | –     |
| Health checks (remote prod/staging)      | ✓ (PR to main/stg) | –                      | ✓ (push main/stg)    | ✓             | ✓            | ✓       | ✓     |
| Environment separation (remote)          | ✓ (manual mode)    | –                      | –                    | –             | –            | ✓ (if selected) | ✓ (if selected) |
| Production tests (guards, keys, retriever)| ✓ (PR to main/stg) | –                     | ✓ (push main/stg)    | –             | –            | ✓       | ✓     |
| Staging tests (env validity/retriever)   | ✓ (PR to main/stg) | –                      | ✓ (push main/stg)    | –             | –            | ✓       | ✓     |
| Deploy Agent to Staging (Railway)        | ✓ (PR to staging/main) | –                   | –                    | ✓             | ✓            | –       | ✓     |
| Deploy Frontend to Staging (Vercel preview)| ✓ (PR to staging/main)| –                 | –                    | ✓             | ✓            | –       | ✓     |
| Post‑deploy tests (staging smoke/E2E)    | ✓ (if deploy jobs succeed) | –             | –                    | ✓             | ✓            | –       | –     |
| Notifications / summaries                | ✓                  | ✓ (agent results)      | ✓                    | ✓             | ✓            | ✓       | ✓     |
| Pre‑commit (husky)                       | – (not configured) | –                      | –                    | –             | –            | –       | –     |
+
+
+
+# GitHub Checks — What They Do (Plain English)
+
+This guide maps each workflow to its triggers, what it does, which checks it exposes in the PR UI, why they matter, and their practical priority.
+
+## CI (`.github/workflows/ci.yml`)
+
+| Item | Description |
+|---|---|
+| Triggers | push to `main`, `develop`, `feat/*`; pull_request to `main`, `develop` |
+| What it does | Installs deps, lints, builds, runs unit tests on Node 18 and 20, then runs integration & E2E suites and a security audit. |
+| Checks | `CI / test (18.x)`, `CI / test (20.x)`, `CI / integration-e2e`, `CI / integration-high-value`, `CI / security` |
+| What each checks |<br>- `test (18.x|20.x)`: Lint + unit tests + build on both Node versions.<br>- `integration-e2e`: Spins up services and runs frontend + agent integration and Playwright E2E flows.<br>- `integration-high-value`: Faster, critical-path integration tests (config, error-handling, API validation).<br>- `security`: `npm audit` across repo to flag vulnerable deps. |
+| Why important |<br>- Node 18/20: guarantees runtime compatibility and catches regressions fast.<br>- integration-e2e: validates the app actually works end-to-end, highest confidence before merge.<br>- integration-high-value: protects the most business-critical flows with quick feedback.<br>- security: prevents known vulnerable libs from shipping. |
+| Priority | `integration-e2e`: High • `test (18.x|20.x)`: High • `integration-high-value`: High • `security`: Medium |
+
+## Test Chef Chopsky Agent (`.github/workflows/test-agent.yml`)
+
+| Item | Description |
+|---|---|
+| Triggers | push/pull_request to `main`/`master` that touch `agent/**` or this workflow |
+| What it does | Builds the agent, starts the Express server in CI, verifies `/health`, then runs the agent test suite, and uploads coverage. |
+| Checks | `Test Chef Chopsky Agent / test-agent` |
+| What it checks | Agent TypeScript build, boot, health endpoint, and all agent tests (including production safety guards behavior). |
+| Why important | Catches backend regressions and ensures production safety guards are enforced correctly. |
+| Priority | High |
+
+## Health Checks and Environment Separation Tests (`.github/workflows/health-checks-and-environment-separation-tests.yml`)
+
+| Item | Description |
+|---|---|
+| Triggers | push to `main`, `staging`, `feat/*`, `feature/*`; pull_request to `main`, `staging`; hourly `schedule`; manual `workflow_dispatch` with `test_type`. |
+| What it does | Probes live staging/production URLs for health, validates env separation, production/staging rules, and emits a summary. |
+| Checks | `health-checks`, `environment-separation`, `production-tests`, `staging-tests`, `test-summary` |
+| What each checks |<br>- `health-checks`: Frontend availability, agent `/health`, and DB connectivity for prod/staging.<br>- `environment-separation`: Confirms config/data isolation (e.g., different indexes, env discriminators).<br>- `production-tests`: Validates prod API key status, retriever type, and guards are active.<br>- `staging-tests`: Validates staging `APP_ENV` and retriever suitability.<br>- `test-summary`: Aggregates results even if some jobs fail/skip. |
+| Why important | Detects misconfig between environments, prevents cross-env data bleed, and ensures prod cannot run in unsafe modes. |
+| Priority | `production-tests`: High • `environment-separation`: High • `health-checks`: High • `staging-tests`: Medium • `test-summary`: Low |
+
+## Staging Deployment (`.github/workflows/staging-deployment.yml`)
+
+| Item | Description |
+|---|---|
+| Triggers | push to `staging`, `feat/*`, `feature/*`; pull_request to `staging`, `main`; manual `workflow_dispatch` (branch, force). |
+| What it does | Decides deployment target URL, validates repo (lint/tests/build/security), deploys agent to Railway + frontend to Vercel preview, runs post-deploy smoke/E2E, then summarizes. |
+| Checks | `setup`, `validate`, `deploy-agent`, `deploy-frontend`, `post-deployment-tests`, `notify` |
+| What each checks |<br>- `setup`: Computes branch → preview URL and whether to deploy.<br>- `validate`: Lint, unit/integration tests, build, and audits prior to deploy.<br>- `deploy-agent`: Pushes agent to Railway staging and verifies `/health`.<br>- `deploy-frontend`: Deploys frontend to Vercel preview and verifies reachability.<br>- `post-deployment-tests`: Staging smoke + targeted Playwright flows and env isolation sanity.<br>- `notify`: Writes deployment summary. |
+| Why important | Prevents bad builds from reaching staging, verifies deployments actually work, and produces a canonical summary for reviewers. |
+| Priority | `validate`: High • `deploy